/**-----------------------------------------------------------------------------------------
* Copyright Â© 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { LABEL_DECIMALS, MIN_MAX_ERROR_MESSAGE, MIN_RATIO } from './constants';
import { isDevMode } from '@angular/core';
/**
 * @hidden
 */
export const formatValue = (value, min, max, label) => {
    const defaultFormattedValue = truncateNumber(value);
    if (typeof label !== 'boolean') {
        if (typeof label.format === 'string') {
            switch (label.format) {
                case 'value':
                    return defaultFormattedValue;
                case 'percent':
                    return `${Math.floor(calculatePercentage(value, min, max))}%`;
                default:
                    return defaultFormattedValue;
            }
        }
        else if (typeof label.format === 'function') {
            return label.format(value);
        }
        else {
            return defaultFormattedValue;
        }
    }
    return defaultFormattedValue;
};
/**
 * @hidden
 */
export const validateRange = (min, max) => {
    if (isDevMode && min > max) {
        throw new Error(MIN_MAX_ERROR_MESSAGE);
    }
};
/**
 * @hidden
 */
export const adjustValueToRange = (min, max, value) => Math.max(Math.min(value, max), min);
/**
 * @hidden
 */
export const calculatePercentage = (value, min, max) => {
    const decimalValue = Math.abs((value - min) / (max - min));
    return decimalValue * 100;
};
/**
 * @hidden
 */
const truncateNumber = (value) => {
    const numberParts = value.toString().split('.');
    return numberParts.length === 1 ? `${numberParts[0]}` : `${numberParts[0]}.${numberParts[1].substr(0, LABEL_DECIMALS)}`;
};
/**
 * @hidden
 */
export const calculateRatio = (min, max, value) => Math.max((value - min) / (max - min), MIN_RATIO);
/**
 * @hidden
 */
export const extractValueFromChanges = (changes, type, value) => changes[type] && changes[type].currentValue !== undefined ? changes[type].currentValue : value;
/**
 * @hidden
 */
export const runAnimation = (changes, animation, previousValue, displayValue) => animation && typeof requestAnimationFrame !== 'undefined' && changes['value'] && previousValue !== displayValue;
/**
 * @hidden
 */
export const stopCurrentAnimation = (changes) => {
    const isAnimationChanged = Boolean(changes['animation']);
    const hasAnimation = isAnimationChanged && changes['animation'].currentValue;
    return isAnimationChanged && !hasAnimation;
};
/**
 * @hidden
 */
export const setProgressBarStyles = (props, renderer) => {
    props.forEach(prop => {
        renderer[prop.method](prop.el, prop.attr, `${prop.attrValue}`);
    });
};
/**
 * @hidden
 */
export const removeProgressBarStyles = (props, renderer) => {
    props.forEach(prop => {
        renderer[prop.method](prop.el, prop.attr);
    });
};
/**
 * @hidden
 */
export const hasElementSize = (element) => {
    return !!(element.style.width && element.style.height);
};
