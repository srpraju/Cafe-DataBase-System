/**-----------------------------------------------------------------------------------------
* Copyright Â© 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withBase = exports.addToPackageJson = exports.addDeclarationToNgModule = exports.applyChanges = void 0;
const tslib_1 = require("tslib");
const schematics_1 = require("@angular-devkit/schematics");
const core_1 = require("@angular-devkit/core");
const ts = tslib_1.__importStar(require("typescript"));
const operators_1 = require("rxjs/operators");
const utils_1 = require("../utils");
function applyChanges(host, path, changes) {
    const recorder = host.beginUpdate(path);
    for (const change of changes) {
        recorder.insertLeft(change.position, change.toAdd);
    }
    host.commitUpdate(recorder);
}
exports.applyChanges = applyChanges;
function addDeclarationToNgModule(options) {
    return (host) => {
        const modulePath = options.module;
        if (!modulePath) {
            return host;
        }
        const sourceText = host.read(modulePath).toString('utf-8');
        const source = ts.createSourceFile(modulePath, sourceText, ts.ScriptTarget.Latest, true);
        const changes = (0, utils_1.addDeclarationToModule)({
            source,
            symbolName: options.symbolName,
            modulePath: options.symbolImport
        });
        applyChanges(host, modulePath, changes);
        return host;
    };
}
exports.addDeclarationToNgModule = addDeclarationToNgModule;
function addToPackageJson(options) {
    return (host) => {
        if (!host.exists('package.json'))
            return host;
        const dependencies = options.dependencies;
        const text = host.read('package.json').toString('utf-8');
        const json = JSON.parse(text);
        json['dependencies'] = Object.assign({}, json['dependencies'], dependencies);
        host.overwrite('package.json', (0, utils_1.stringify)(json));
        return host;
    };
}
exports.addToPackageJson = addToPackageJson;
const inlineTemplate = ({ inlineTemplate }) => inlineTemplate ? (0, schematics_1.filter)((path) => !path.endsWith('html')) : (0, schematics_1.noop)();
const inlineStyle = ({ inlineStyle }) => inlineStyle ? (0, schematics_1.filter)((path) => !path.endsWith('__styleext__')) : (0, schematics_1.noop)();
function withBase(componentTemplate, rules) {
    return (options) => (host, context) => {
        const extendTemplateContext = (additional = {}) => (0, schematics_1.template)({
            ...core_1.strings,
            ...options,
            'folder-name': (0, utils_1.folderName)(options),
            'full-path': `${options.sourceDir}/${options.path}`,
            selector: (0, utils_1.buildSelector)(options),
            ...additional
        });
        const baseComponent = (templateContext) => {
            const templateSource = (0, schematics_1.apply)((0, schematics_1.url)('../component/files'), [
                inlineTemplate(options),
                inlineStyle(options),
                extendTemplateContext(templateContext)
            ]);
            const allRules = (0, schematics_1.chain)([
                (0, schematics_1.branchAndMerge)((0, schematics_1.mergeWith)(templateSource)),
                rules
            ]);
            return (0, utils_1.asObservable)(allRules(host, context));
        };
        return componentTemplate(context).pipe((0, operators_1.switchMap)(baseComponent));
    };
}
exports.withBase = withBase;
//# sourceMappingURL=index.js.map