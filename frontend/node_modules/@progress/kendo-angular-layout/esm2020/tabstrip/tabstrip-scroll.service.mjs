/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { DEFAULT_SCROLL_BEHAVIOR } from './constants';
import { Injectable, NgZone } from '@angular/core';
import { isDocumentAvailable } from '@progress/kendo-angular-common';
import { Subject } from 'rxjs';
import { getActiveTab, isTablistHorizontal, mouseScrollEnabled } from './util';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export class ScrollService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.position = 0;
        this.scrollButtonActiveStateChange = new Subject();
        this.isDisabled = (buttonType) => this.owner[`${buttonType}ScrollButton`].host.nativeElement.classList.contains('k-disabled');
    }
    get tablistElement() {
        return this.owner.tablist.nativeElement;
    }
    get tabstripSize() {
        const hostElement = this.owner.wrapper.nativeElement;
        const wrapperWidth = parseFloat(getComputedStyle(hostElement).width);
        const wrapperHeight = parseFloat(getComputedStyle(hostElement).height);
        return isTablistHorizontal(this.owner.tabPosition) ? wrapperWidth : wrapperHeight;
    }
    get tablistOverflowSize() {
        if (!isDocumentAvailable()) {
            return 0;
        }
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        const overflowSize = Math.floor(this.tablistElement[isHorizontal ? 'scrollWidth' : 'scrollHeight']
            - this.tablistElement.getBoundingClientRect()[isHorizontal ? 'width' : 'height']);
        return overflowSize < 0 ? 0 : overflowSize;
    }
    get tabsOverflow() {
        return this.tablistOverflowSize > 0;
    }
    get scrollButtonsSize() {
        if (!this.owner.hasScrollButtons) {
            return 0;
        }
        const prevRect = this.owner.prevScrollButton.hostBoundingClientRect;
        const prevSize = isTablistHorizontal(this.owner.tabPosition) ? prevRect.width : prevRect.height;
        const nextRect = this.owner.nextScrollButton.hostBoundingClientRect;
        const nextSize = isTablistHorizontal(this.owner.tabPosition) ? nextRect.width : nextRect.height;
        return prevSize + nextSize;
    }
    toggleScrollButtonsState() {
        const tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        const currentPrevButtonActive = !this.isDisabled('prev');
        const currentNextButtonActive = !this.isDisabled('next');
        const calculatedPrevButtonActive = this.position > 0 && this.tablistOverflowSize > 0;
        const calculatedNextButtonActive = this.position < this.tablistOverflowSize + this.scrollButtonsSize && this.tablistOverflowSize > 0;
        if (calculatedPrevButtonActive !== currentPrevButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));
        }
        if (calculatedNextButtonActive !== currentNextButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));
        }
    }
    scrollToSelectedTab() {
        if (!this.tabsOverflow) {
            return;
        }
        const { index: activeIndex } = getActiveTab(this.owner.tabs);
        if (activeIndex === -1) {
            return;
        }
        this.position += this.getScrollOffset(activeIndex);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
        const tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        const isFirstTabActive = activeIndex === 0;
        const isLastTabActive = activeIndex === this.owner.tabs.length - 1;
        if (isFirstTabActive && !this.isDisabled('prev')) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', false));
        }
        if (isLastTabActive && !this.isDisabled('next')) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', false));
        }
    }
    getScrollOffset(activeIndex) {
        if (!isDocumentAvailable()) {
            return 0;
        }
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        this.tablistElement[`scroll${isHorizontal ? 'Left' : 'Top'}`] = this.position;
        const activeTabRect = this.tablistElement.children[activeIndex].getBoundingClientRect();
        const tablistRect = this.tablistElement.getBoundingClientRect();
        const end = isHorizontal ? 'right' : 'bottom';
        const start = isHorizontal ? 'left' : 'top';
        const activeTabStart = activeTabRect[start];
        const activeTabEnd = activeTabRect[end];
        const tablistStart = tablistRect[start];
        const tablistEnd = tablistRect[end];
        const tabEndIsInVisibleRange = activeTabEnd <= tablistEnd;
        const tabStartIsInVisibleRange = activeTabStart >= tablistStart;
        const isWholeTabVisible = tabEndIsInVisibleRange && tabStartIsInVisibleRange;
        if (isWholeTabVisible) {
            return 0;
        }
        if (!tabEndIsInVisibleRange) {
            return activeTabEnd - tablistEnd;
        }
        if (!tabStartIsInVisibleRange) {
            return activeTabStart - tablistStart;
        }
    }
    onMouseScroll(event) {
        event.preventDefault();
        if (!mouseScrollEnabled(this.owner.scrollable)) {
            return;
        }
        const direction = event.deltaY < 0 ? 'prev' : 'next';
        this.calculateListPosition(direction, this.owner.scrollable.mouseScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
    }
    scrollTabs(direction) {
        this.calculateListPosition(direction, this.owner.scrollable.buttonScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition) && this.tablistElement) {
            this.tablistElement.scrollTo({ left: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        else {
            this.tablistElement.scrollTo({ top: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        this.toggleScrollButtonsState();
    }
    calculateListPosition(direction, scrollSpeed) {
        const adjustedMaxScroll = this.tablistOverflowSize + this.scrollButtonsSize;
        if (direction === 'prev' && this.position > 0) {
            this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
        }
        else if (direction === 'next' && this.position < adjustedMaxScroll) {
            if (this.position + scrollSpeed > adjustedMaxScroll) {
                this.position = adjustedMaxScroll;
                return;
            }
            this.position += scrollSpeed;
        }
    }
    restoreScrollPosition() {
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
    }
    toggleButtonActiveState(buttonType, active) {
        this.scrollButtonActiveStateChange.next({ buttonType, active });
    }
}
ScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ScrollService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
ScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ScrollService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ScrollService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });
