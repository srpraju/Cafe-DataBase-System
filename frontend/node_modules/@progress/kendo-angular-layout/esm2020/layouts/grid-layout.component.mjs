/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, HostBinding, Input, Renderer2, ElementRef, isDevMode } from '@angular/core';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
import { ALIGN_PREFIX, generateGapStyle, generateGridStyle, GRID_JUSTIFY_PREFIX, normalizeGap, VERTICAL_SUFFIX, validateGridLayoutRowsCols } from './util';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { isPresent } from '../common/util';
import { isChanged } from '@progress/kendo-angular-common';
import * as i0 from "@angular/core";
import * as i1 from "@progress/kendo-angular-l10n";
/**
 * Represents the [Kendo UI GridLayout component for Angular]({% slug overview_gridlayout %}).
 */
export class GridLayoutComponent {
    constructor(renderer, element, localization) {
        this.renderer = renderer;
        this.element = element;
        this.localization = localization;
        this.hostClass = true;
        /**
         * Specifies the gaps between the elements. The default value is `0`
         * ([see example]({% slug layout_gridlayout %}#toc-gaps)).
         */
        this.gap = 0;
        this._align = {
            horizontal: 'stretch',
            vertical: 'stretch'
        };
        validatePackage(packageMetadata);
    }
    get dir() {
        return this.direction;
    }
    /**
     * Specifies the horizontal and vertical alignment of the inner GridLayout elements
     * ([see example]({% slug layout_gridlayout %}#toc-alignment)).
     */
    set align(align) {
        this._align = Object.assign({}, this._align, align);
        this.handleAlignClasses();
    }
    get align() {
        return this._align;
    }
    ngAfterViewInit() {
        this.handleAlignClasses();
        this.handleGridTemplateStyling('rows');
        this.handleGridTemplateStyling('cols');
        this.setGap();
    }
    ngOnChanges(changes) {
        if (isChanged('gap', changes)) {
            this.setGap();
        }
        if (isChanged('rows', changes)) {
            this.handleGridTemplateStyling('rows');
        }
        if (isChanged('cols', changes)) {
            this.handleGridTemplateStyling('cols');
        }
    }
    handleAlignClasses() {
        const elem = this.element.nativeElement;
        if (isPresent(this.justifyClass)) {
            this.renderer.removeClass(elem, this.justifyClass);
        }
        if (isPresent(this.alignClass)) {
            this.renderer.removeClass(elem, this.alignClass);
        }
        this.justifyClass = `${GRID_JUSTIFY_PREFIX}-${this.align.horizontal}`;
        this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
        this.renderer.addClass(elem, this.justifyClass);
        this.renderer.addClass(elem, this.alignClass);
    }
    setGap() {
        const parsedGap = normalizeGap(this.gap);
        const gapStyle = generateGapStyle(parsedGap);
        this.renderer.setStyle(this.element.nativeElement, 'gap', gapStyle);
    }
    handleGridTemplateStyling(type) {
        if (!isPresent(this[type])) {
            return;
        }
        const isValid = validateGridLayoutRowsCols(this[type]);
        if (!isValid && isDevMode()) {
            const valueType = type === 'rows' ? 'GridLayoutRowSize' : 'GridLayoutColSize';
            throw new Error(`The provided ${type} value contains invalid elements. The array supports values of type number, string or ${valueType}.`);
        }
        const gridTemplateStyle = type === 'rows' ? 'grid-template-rows' : 'grid-template-columns';
        const gridStyle = generateGridStyle(this[type], type);
        this.renderer.setStyle(this.element.nativeElement, gridTemplateStyle, gridStyle.join(' '));
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
}
GridLayoutComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: GridLayoutComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
GridLayoutComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: GridLayoutComponent, selector: "kendo-gridlayout", inputs: { rows: "rows", cols: "cols", gap: "gap", align: "align" }, host: { properties: { "class.k-grid-layout": "this.hostClass", "attr.dir": "this.dir" } }, providers: [
        LocalizationService,
        {
            provide: L10N_PREFIX,
            useValue: 'kendo.gridlayout'
        }
    ], exportAs: ["kendoGridLayout"], usesOnChanges: true, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: GridLayoutComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoGridLayout',
                    selector: 'kendo-gridlayout',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.gridlayout'
                        }
                    ],
                    template: `
        <ng-content></ng-content>
    `
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i1.LocalizationService }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-grid-layout']
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], rows: [{
                type: Input
            }], cols: [{
                type: Input
            }], gap: [{
                type: Input
            }], align: [{
                type: Input
            }] } });
