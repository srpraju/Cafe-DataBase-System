/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, ContentChildren, ElementRef, HostBinding, Input, NgZone, QueryList, Renderer2 } from '@angular/core';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { Subscription } from 'rxjs';
import { TileLayoutDraggingService } from './dragging-service';
import { TileLayoutKeyboardNavigationService } from './keyboard-navigation.service';
import { isPresent } from './../common/util';
import { RESIZE_DIRECTIONS, RTL_RESIZE_DIRECTIONS } from './constants';
import { TileLayoutItemHeaderComponent } from './tilelayout-item-header.component';
import { getId } from './util';
import * as i0 from "@angular/core";
import * as i1 from "@progress/kendo-angular-l10n";
import * as i2 from "./dragging-service";
import * as i3 from "./keyboard-navigation.service";
import * as i4 from "./tilelayout-item-header.component";
import * as i5 from "@angular/common";
import * as i6 from "./tilelayout-resize-handle.directive";
/**
 * Represents a tile item within the TileLayoutComponent.
 */
export class TileLayoutItemComponent {
    constructor(elem, zone, renderer, localization, draggingService, keyboardNavigationService) {
        this.elem = elem;
        this.zone = zone;
        this.renderer = renderer;
        this.localization = localization;
        this.draggingService = draggingService;
        this.keyboardNavigationService = keyboardNavigationService;
        /**
         * Determines how many rows will the tile item span ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default 1
         */
        this.rowSpan = 1;
        /**
         * Determines how many columns will the tile item span ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default 1
         */
        this.colSpan = 1;
        /**
         * Determines whether the item can be reordered. By default all items are reorderable when the [reorderable]({% slug api_layout_tilelayoutcomponent %}#toc-reorderable) property of the TileLayoutComponent is set to `true` ([see example]({% slug reordering_tilelayout %}#toc-disable-reordering)).
         *
         * @default true
         */
        this.reorderable = true;
        /**
         * Determines whether the item can be resized. By default all items are resizable when the [resizable]({% slug api_layout_tilelayoutcomponent %}#resizable) property of the TileLayoutComponent is set to `true` ([see example]({% slug resizing_tilelayout %}#toc-disable-resizing)).
         * @default true
         */
        this.resizable = true;
        this.itemClass = true;
        this.hostRole = 'listitem';
        /**
         * @hidden
         */
        this.titleId = '';
        this.subs = new Subscription();
        this.subs.add(this.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
        }));
        this.subs.add(this.draggingService.resizable.subscribe(resizable => {
            this.resizeDirections = resizable && this.resizable ?
                this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;
        }));
        this.titleId = getId('k-tilelayout-title');
    }
    /**
     * Determines the order of the tile items within the TileLayout.
     * If not set, the items will receive increasing sequential order in accordance with
     * their position in the DOM when initially rendered.
     */
    set order(value) {
        this._order = value;
        this.renderer.setStyle(this.elem.nativeElement, 'order', `${this._order}`);
    }
    get order() {
        return this._order;
    }
    get hostDropEffect() {
        return this.isResizable || this.isReorderable ? 'execute' : undefined;
    }
    get hostTabindex() {
        return this.isNavigable ? '0' : undefined;
    }
    get ariaKeyShortcuts() {
        return this.isNavigable ? 'Enter' : undefined;
    }
    get hostGrabbed() {
        return this.isResizable || this.isReorderable;
    }
    get hostLabelledBy() {
        return this.title ? this.titleId : undefined;
    }
    get colEnd() {
        return `span ${this.colSpan}`;
    }
    get rowEnd() {
        return `span ${this.rowSpan}`;
    }
    get colStart() {
        return isPresent(this.col) ? this.col.toString() : undefined;
    }
    get rowStart() {
        return isPresent(this.row) ? this.row.toString() : undefined;
    }
    /**
     * @hidden
     */
    get isReorderable() {
        return this.reorderable && this.draggingService.reorderable.getValue();
    }
    /**
     * @hidden
     */
    get isNavigable() {
        return this.keyboardNavigationService.navigable.getValue();
    }
    /**
     * @hidden
     */
    get isResizable() {
        return this.resizable && this.draggingService.resizable.getValue();
    }
    ngAfterViewInit() {
        const elem = this.elem.nativeElement;
        const keyboardNavigation = this.keyboardNavigationService;
        this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {
            this.toggleCursorClass(reorderable && this.reorderable);
            if (this.headers?.first) {
                this.headers.first.reorderable = reorderable && this.reorderable;
            }
        }));
        this.subs.add(keyboardNavigation.navigable.subscribe(isNavigable => {
            if (isNavigable) {
                this.keyboardNavigationSubs = new Subscription();
                this.focusableItems = keyboardNavigation.getAllFocusableChildren(elem);
                this.zone.runOutsideAngular(() => {
                    keyboardNavigation.changeTabIndex('-1', elem, this.focusableItems);
                    this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'keydown', event => keyboardNavigation.onKeyDown(event, elem, this.focusableItems, this.draggingService.tileLayoutSettings)));
                    this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'click', event => keyboardNavigation.onClick(event, elem, this.focusableItems)));
                    this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'focusout', event => keyboardNavigation.onFocusOut(event, elem, this.focusableItems)));
                });
            }
            else if (this.focusableItems) {
                this.focusableItems.forEach((focusItem) => {
                    this.renderer.setAttribute(focusItem, 'tabindex', '0');
                });
                this.keyboardNavigationSubs.unsubscribe();
            }
        }));
    }
    ngOnChanges(changes) {
        if (changes['reorderable'] && !changes['reorderable'].firstChange) {
            this.toggleCursorClass(changes['reorderable'].currentValue && this.draggingService.reorderable.getValue());
        }
        if (changes['resizable']) {
            this.resizeDirections = this.resizable && this.draggingService.resizable.getValue() ?
                this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;
        }
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        if (this.keyboardNavigationSubs) {
            this.keyboardNavigationSubs.unsubscribe();
        }
    }
    toggleCursorClass(isReorderable) {
        const headerEl = this.elem.nativeElement.querySelector('.k-tilelayout-item-header');
        if (!headerEl) {
            return;
        }
        if (isReorderable) {
            this.renderer.addClass(headerEl, 'k-cursor-grab');
        }
        else {
            this.renderer.removeClass(headerEl, 'k-cursor-grab');
        }
    }
}
TileLayoutItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TileLayoutItemComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i1.LocalizationService }, { token: i2.TileLayoutDraggingService }, { token: i3.TileLayoutKeyboardNavigationService }], target: i0.ɵɵFactoryTarget.Component });
TileLayoutItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: TileLayoutItemComponent, selector: "kendo-tilelayout-item", inputs: { title: "title", rowSpan: "rowSpan", colSpan: "colSpan", order: "order", col: "col", row: "row", reorderable: "reorderable", resizable: "resizable" }, host: { properties: { "class.k-tilelayout-item": "this.itemClass", "class.k-card": "this.itemClass", "attr.role": "this.hostRole", "attr.aria-dropeffect": "this.hostDropEffect", "attr.tabindex": "this.hostTabindex", "attr.aria-keyshortcuts": "this.ariaKeyShortcuts", "attr.aria-grabbed": "this.hostGrabbed", "attr.aria-labelledby": "this.hostLabelledBy", "style.grid-column-end": "this.colEnd", "style.grid-row-end": "this.rowEnd", "style.grid-column-start": "this.colStart", "style.grid-row-start": "this.rowStart" } }, queries: [{ propertyName: "headers", predicate: TileLayoutItemHeaderComponent }], usesOnChanges: true, ngImport: i0, template: `
        <kendo-tilelayout-item-header [reorderable]="isReorderable" *ngIf="title">
            <h5 [id]="titleId" class="k-card-title">{{ title }}</h5>
        </kendo-tilelayout-item-header>
        <ng-content></ng-content>
        <ng-container *ngIf="resizable">
            <div
                *ngFor="let dir of resizeDirections"
                class="k-resize-handle k-cursor-{{dir}}-resize k-touch-action-none"
                kendoTileLayoutResizeHandle
                [rtl]="rtl"
                [resizeDirection]="dir">
            </div>
        </ng-container>
    `, isInline: true, components: [{ type: i4.TileLayoutItemHeaderComponent, selector: "kendo-tilelayout-item-header", inputs: ["reorderable"] }], directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i6.TileLayoutResizeHandleDirective, selector: "[kendoTileLayoutResizeHandle]", inputs: ["resizeDirection", "rtl"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TileLayoutItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-tilelayout-item',
                    template: `
        <kendo-tilelayout-item-header [reorderable]="isReorderable" *ngIf="title">
            <h5 [id]="titleId" class="k-card-title">{{ title }}</h5>
        </kendo-tilelayout-item-header>
        <ng-content></ng-content>
        <ng-container *ngIf="resizable">
            <div
                *ngFor="let dir of resizeDirections"
                class="k-resize-handle k-cursor-{{dir}}-resize k-touch-action-none"
                kendoTileLayoutResizeHandle
                [rtl]="rtl"
                [resizeDirection]="dir">
            </div>
        </ng-container>
    `
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.LocalizationService }, { type: i2.TileLayoutDraggingService }, { type: i3.TileLayoutKeyboardNavigationService }]; }, propDecorators: { title: [{
                type: Input
            }], rowSpan: [{
                type: Input
            }], colSpan: [{
                type: Input
            }], order: [{
                type: Input
            }], col: [{
                type: Input
            }], row: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], resizable: [{
                type: Input
            }], itemClass: [{
                type: HostBinding,
                args: ['class.k-tilelayout-item']
            }, {
                type: HostBinding,
                args: ['class.k-card']
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], hostDropEffect: [{
                type: HostBinding,
                args: ['attr.aria-dropeffect']
            }], hostTabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], ariaKeyShortcuts: [{
                type: HostBinding,
                args: ['attr.aria-keyshortcuts']
            }], hostGrabbed: [{
                type: HostBinding,
                args: ['attr.aria-grabbed']
            }], hostLabelledBy: [{
                type: HostBinding,
                args: ['attr.aria-labelledby']
            }], colEnd: [{
                type: HostBinding,
                args: ['style.grid-column-end']
            }], rowEnd: [{
                type: HostBinding,
                args: ['style.grid-row-end']
            }], colStart: [{
                type: HostBinding,
                args: ['style.grid-column-start']
            }], rowStart: [{
                type: HostBinding,
                args: ['style.grid-row-start']
            }], headers: [{
                type: ContentChildren,
                args: [TileLayoutItemHeaderComponent]
            }] } });
