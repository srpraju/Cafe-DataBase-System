/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
/* eslint-disable no-unused-expressions */
import { Injectable, NgZone, Renderer2 } from '@angular/core';
import { Keys } from '@progress/kendo-angular-common';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { BehaviorSubject } from 'rxjs';
import { focusableSelector } from '@progress/kendo-angular-common';
import { getCurrentCol, shouldReorder, shouldResize } from './util';
import * as i0 from "@angular/core";
import * as i1 from "@progress/kendo-angular-l10n";
/**
 * @hidden
 */
export class TileLayoutKeyboardNavigationService {
    constructor(zone, renderer, localization) {
        this.zone = zone;
        this.renderer = renderer;
        this.localization = localization;
        this.navigable = new BehaviorSubject(false);
        this.localizationSubscription = this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl);
    }
    ngOnDestroy() {
        this.localizationSubscription.unsubscribe();
    }
    onKeyDown(event, elem, focusableItems, settings) {
        const keyCode = event.keyCode;
        const isTileFocused = document.activeElement === elem;
        const focusedTile = settings.items.find(item => item.elem.nativeElement === elem);
        const col = getCurrentCol(focusedTile, settings, this.rtl);
        if (keyCode === Keys.Enter && isTileFocused && focusableItems.length > 0) {
            this.changeTabIndex('0', elem, focusableItems);
            focusableItems[0].focus();
        }
        else if (keyCode === Keys.Escape) {
            this.changeTabIndex('-1', elem, focusableItems);
            elem.focus();
        }
        else if ((event.ctrlKey || event.metaKey) && isTileFocused && focusedTile.isResizable) {
            event.preventDefault();
            this.zone.run(() => {
                this.resizeItem(keyCode, focusedTile, settings, col);
            });
        }
        else if (event.shiftKey && isTileFocused && focusedTile.isReorderable) {
            this.zone.run(() => {
                this.reorderItem(keyCode, focusedTile, settings, col);
            });
        }
        else if (keyCode === Keys.Tab && !isTileFocused) {
            this.keepFocusWithinComponent(event, elem);
        }
    }
    onFocusOut(event, elem, focusableItems) {
        const isTargetFocusable = focusableItems.includes(event.target);
        const isRelatedTargetFocusable = focusableItems.includes(event.relatedTarget);
        if (isTargetFocusable && !isRelatedTargetFocusable) {
            this.changeTabIndex('-1', elem, focusableItems);
            event.relatedTarget?.focus();
        }
    }
    onClick(event, elem, focusableItems) {
        const isTargetFocusable = focusableItems.includes(event.target);
        if (isTargetFocusable) {
            this.changeTabIndex('0', elem, focusableItems);
            event.target.focus();
        }
    }
    changeTabIndex(tabIndex, elem, focusableItems) {
        this.renderer.setAttribute(elem, 'tabindex', tabIndex === '0' ? '-1' : '0');
        focusableItems.forEach((focusItem) => {
            this.renderer.setAttribute(focusItem, 'tabindex', tabIndex);
        });
    }
    getAllFocusableChildren(parent) {
        return Array.from(parent.querySelectorAll(focusableSelector)).filter((element) => element.offsetParent !== null);
    }
    ;
    resizeItem(keyCode, focusedTile, settings, col) {
        const { resizeRight, resizeLeft, resizeDown, resizeUp } = shouldResize(keyCode, col, focusedTile, settings);
        const resizeHorizontal = resizeLeft || resizeRight;
        const resizeVertical = resizeDown || resizeUp;
        const resizeDir = resizeLeft || resizeUp ? -1 : 1;
        if (resizeHorizontal) {
            focusedTile.colSpan += resizeDir;
        }
        else if (resizeVertical) {
            focusedTile.rowSpan += resizeDir;
        }
    }
    reorderItem(keyCode, focusedTile, settings, col) {
        const { reorderLeft, reorderRight } = shouldReorder(keyCode, col, focusedTile, settings);
        const onReorderRight = () => {
            const nextTile = this.targetTile(focusedTile, settings.items, 1);
            if (nextTile) {
                focusedTile.order += 1;
                nextTile.order -= 1;
            }
        };
        const onReorderLeft = () => {
            const prevTile = this.targetTile(focusedTile, settings.items, -1);
            if (prevTile) {
                focusedTile.order -= 1;
                prevTile.order += 1;
            }
        };
        if (reorderRight || reorderLeft) {
            const reorderDir = reorderRight ? 1 : -1;
            if (focusedTile.col) {
                focusedTile.col += reorderDir;
            }
            else {
                reorderRight ? onReorderRight() : onReorderLeft();
            }
        }
    }
    keepFocusWithinComponent(event, wrapper) {
        const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);
        const tabAfterLastFocusable = !event.shiftKey && event.target === lastFocusable;
        const shiftTabAfterFirstFocusable = event.shiftKey && event.target === firstFocusable;
        if (tabAfterLastFocusable) {
            event.preventDefault();
            firstFocusable.focus();
            wrapper.blur();
        }
        if (shiftTabAfterFirstFocusable) {
            event.preventDefault();
            lastFocusable.focus();
        }
    }
    getFirstAndLastFocusable(parent) {
        const all = this.getAllFocusableChildren(parent);
        const firstFocusable = all.length > 0 ? all[0] : parent;
        const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;
        return [firstFocusable, lastFocusable];
    }
    ;
    targetTile(focusedTile, items, offset) {
        return items.find(item => item.order === focusedTile.order + offset);
    }
}
TileLayoutKeyboardNavigationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TileLayoutKeyboardNavigationService, deps: [{ token: i0.NgZone }, { token: i0.Renderer2 }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
TileLayoutKeyboardNavigationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TileLayoutKeyboardNavigationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TileLayoutKeyboardNavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.LocalizationService }]; } });
