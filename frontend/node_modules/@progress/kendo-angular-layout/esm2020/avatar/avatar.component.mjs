/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, HostBinding, Input, isDevMode, Renderer2, ElementRef } from '@angular/core';
import { validatePackage } from '@progress/kendo-licensing';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { getStylingClasses, mapShapeToRounded } from '../common/util';
import { packageMetadata } from '../package-metadata';
import * as i0 from "@angular/core";
import * as i1 from "@progress/kendo-angular-l10n";
import * as i2 from "@progress/kendo-angular-icons";
import * as i3 from "./l10n/localized-messages.directive";
import * as i4 from "@angular/common";
const DEFAULT_ROUNDED = 'full';
const DEFAULT_SIZE = 'medium';
const DEFAULT_THEME_COLOR = 'primary';
const DEFAULT_FILL_MODE = 'solid';
/**
 * Displays images, icons or initials representing people or other entities.
 */
export class AvatarComponent {
    constructor(localization, renderer, element) {
        this.localization = localization;
        this.renderer = renderer;
        this.element = element;
        this.hostClass = true;
        /**
         * Sets a border to the avatar.
         */
        this.border = false;
        this._themeColor = DEFAULT_THEME_COLOR;
        this._size = DEFAULT_SIZE;
        this._fillMode = DEFAULT_FILL_MODE;
        this._rounded = DEFAULT_ROUNDED;
        validatePackage(packageMetadata);
    }
    /**
     * @hidden
     */
    get borderClass() {
        return this.border;
    }
    /**
     * @hidden
     */
    get flexBasis() {
        return this.width;
    }
    /**
     * Sets the shape for the avatar.
     * @hidden
     */
    set shape(shape) {
        this.rounded = mapShapeToRounded(shape);
    }
    /**
     * Specifies the size of the avatar
     * ([see example]({% slug appearance_avatar %}#toc-size)).
     *
     * The possible values are:
     * * `small`
     * * `medium` (Default)
     * * `large`
     * * `none`
     */
    set size(size) {
        if (size !== this._size) {
            const newSize = size ? size : DEFAULT_SIZE;
            this.handleClasses('size', newSize);
            this._size = newSize;
        }
    }
    get size() {
        return this._size;
    }
    /**
     * Specifies the rounded styling of the avatar
     * ([see example]({% slug appearance_avatar %}#toc-rounded-corners)).
     *
     * The possible values are:
     * * `small`
     * * `medium`
     * * `large`
     * * `full` (Default)
     * * `none`
     */
    set rounded(rounded) {
        if (rounded !== this._rounded) {
            const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
            this.handleClasses('rounded', newRounded);
            this._rounded = newRounded;
        }
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Specifies the theme color of the avatar.
     * The theme color will be applied as background and border color, while also amending the text color accordingly.
     *
     * The possible values are:
     * * `base`&mdash; Applies the base coloring value.
     * * `primary` (Default)&mdash;Applies coloring based on primary theme color.
     * * `secondary`&mdash;Applies coloring based on secondary theme color.
     * * `tertiary`&mdash; Applies coloring based on tertiary theme color.
     * * `info`&mdash;Applies coloring based on info theme color.
     * * `success`&mdash; Applies coloring based on success theme color.
     * * `warning`&mdash; Applies coloring based on warning theme color.
     * * `error`&mdash; Applies coloring based on error theme color.
     * * `dark`&mdash; Applies coloring based on dark theme color.
     * * `light`&mdash; Applies coloring based on light theme color.
     * * `inverse`&mdash; Applies coloring based on inverted theme color.
     * * `none`&mdash; Removes the styling associated with the theme color.
     */
    set themeColor(themeColor) {
        if (themeColor !== this._themeColor) {
            const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;
            this._themeColor = newThemeColor;
            this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
        }
    }
    get themeColor() {
        return this._themeColor;
    }
    /**
     * Specifies the appearance fill style of the avatar.
     *
     * The possible values are:
     * * `solid` (Default)
     * * `outline`
     * * `none`
     */
    set fillMode(fillMode) {
        if (fillMode !== this.fillMode) {
            const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
            this._fillMode = newFillMode;
            this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
        }
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * Specifies the appearance fill style of the avatar.
     * Deprecated, left for backward compatibility.
     *
     * @hidden
     */
    set fill(fillMode) {
        this.fillMode = fillMode;
    }
    /**
     * @hidden
     */
    get avatarWidth() {
        return this.width;
    }
    /**
     * @hidden
     */
    get avatarHeight() {
        return this.height;
    }
    /**
     * Defines an SVGIcon to be rendered.
     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgIcon(icon) {
        if (isDevMode() && icon && this.icon && this.iconClass) {
            throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');
        }
        this._svgIcon = icon;
    }
    get svgIcon() {
        return this._svgIcon;
    }
    ngOnInit() {
        this.verifyProperties();
    }
    ngAfterViewInit() {
        const stylingInputs = ['size', 'rounded'];
        stylingInputs.forEach(input => {
            this.handleClasses(input, this[input]);
        });
        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
    }
    /**
     * @hidden
     */
    get customAvatar() {
        return !(this.imageSrc || this.initials || this.icon || this.iconClass);
    }
    verifyProperties() {
        if (!isDevMode()) {
            return;
        }
        const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];
        const inputsLength = inputs.filter((value) => value).length;
        if (inputsLength > 1) {
            throw new Error(`
                Invalid property configuration given.
                The kendo-avatar component can accept only one of:
                icon, imageSrc or initials properties.
            `);
        }
    }
    handleClasses(styleType, value) {
        const elem = this.element.nativeElement;
        const classes = getStylingClasses('avatar', styleType, this[styleType], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    handleFillModeAndThemeColorClasses(fill, themeColor) {
        const wrapperElement = this.element.nativeElement;
        // remove existing fill and theme color classes
        const currentClasses = Array.from(wrapperElement.classList);
        const classesToRemove = currentClasses.filter(cl => {
            return cl.startsWith('k-avatar-solid') || cl.startsWith('k-avatar-outline');
        });
        classesToRemove.forEach((cl => this.renderer.removeClass(wrapperElement, cl)));
        // add fill if needed
        if (fill !== 'none') {
            this.renderer.addClass(wrapperElement, `k-avatar-${fill}`);
        }
        // add theme color class if fill and theme color
        if (fill !== 'none' && themeColor !== 'none') {
            this.renderer.addClass(wrapperElement, `k-avatar-${fill}-${themeColor}`);
        }
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
}
AvatarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AvatarComponent, deps: [{ token: i1.LocalizationService }, { token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
AvatarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: AvatarComponent, selector: "kendo-avatar", inputs: { shape: "shape", size: "size", rounded: "rounded", themeColor: "themeColor", fillMode: "fillMode", fill: "fill", border: "border", iconClass: "iconClass", width: "width", height: "height", cssStyle: "cssStyle", initials: "initials", icon: "icon", imageSrc: "imageSrc", svgIcon: "svgIcon" }, host: { properties: { "class.k-avatar": "this.hostClass", "class.k-avatar-bordered": "this.borderClass", "style.flexBasis": "this.flexBasis", "style.width": "this.avatarWidth", "style.height": "this.avatarHeight" } }, providers: [
        LocalizationService,
        {
            provide: L10N_PREFIX,
            useValue: 'kendo.avatar'
        }
    ], ngImport: i0, template: `
        <ng-container kendoAvatarLocalizedMessages
            i18n-avatarAlt="kendo.avatar.avatarAlt|The alt attribute text of the image in the avatar."
            avatarAlt="Avatar"
        >
        </ng-container>

        <ng-content *ngIf="customAvatar"></ng-content>

        <ng-container *ngIf="imageSrc">
            <span class="k-avatar-image">
                <img src="{{ imageSrc }}" [alt]="textFor('avatarAlt')" [ngStyle]="cssStyle" />
            </span>
        </ng-container>

        <ng-container *ngIf="initials">
            <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        </ng-container>

        <ng-container *ngIf="icon || iconClass || svgIcon">
            <span class="k-avatar-icon">
                <kendo-icon-wrapper
                    [ngStyle]="cssStyle"
                    [name]="icon"
                    [customFontClass]="iconClass"
                    [svgIcon]="svgIcon"
                >
                </kendo-icon-wrapper>
            </span>
        </ng-container>
    `, isInline: true, components: [{ type: i2.IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }], directives: [{ type: i3.LocalizedAvatarMessagesDirective, selector: "[kendoAvatarLocalizedMessages]" }, { type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AvatarComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.avatar'
                        }
                    ],
                    selector: 'kendo-avatar',
                    template: `
        <ng-container kendoAvatarLocalizedMessages
            i18n-avatarAlt="kendo.avatar.avatarAlt|The alt attribute text of the image in the avatar."
            avatarAlt="Avatar"
        >
        </ng-container>

        <ng-content *ngIf="customAvatar"></ng-content>

        <ng-container *ngIf="imageSrc">
            <span class="k-avatar-image">
                <img src="{{ imageSrc }}" [alt]="textFor('avatarAlt')" [ngStyle]="cssStyle" />
            </span>
        </ng-container>

        <ng-container *ngIf="initials">
            <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        </ng-container>

        <ng-container *ngIf="icon || iconClass || svgIcon">
            <span class="k-avatar-icon">
                <kendo-icon-wrapper
                    [ngStyle]="cssStyle"
                    [name]="icon"
                    [customFontClass]="iconClass"
                    [svgIcon]="svgIcon"
                >
                </kendo-icon-wrapper>
            </span>
        </ng-container>
    `
                }]
        }], ctorParameters: function () { return [{ type: i1.LocalizationService }, { type: i0.Renderer2 }, { type: i0.ElementRef }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-avatar']
            }], borderClass: [{
                type: HostBinding,
                args: ['class.k-avatar-bordered']
            }], flexBasis: [{
                type: HostBinding,
                args: ['style.flexBasis']
            }], shape: [{
                type: Input
            }], size: [{
                type: Input
            }], rounded: [{
                type: Input
            }], themeColor: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], fill: [{
                type: Input
            }], border: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], width: [{
                type: Input
            }], avatarWidth: [{
                type: HostBinding,
                args: ['style.width']
            }], height: [{
                type: Input
            }], avatarHeight: [{
                type: HostBinding,
                args: ['style.height']
            }], cssStyle: [{
                type: Input
            }], initials: [{
                type: Input
            }], icon: [{
                type: Input
            }], imageSrc: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }] } });
